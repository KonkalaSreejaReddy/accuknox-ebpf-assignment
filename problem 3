from bcc import BPF
import socket
import ctypes

# eBPF program embedded as a string
bpf_program = """
#include <uapi/linux/bpf.h>
#include <uapi/linux/if_ether.h>
#include <uapi/linux/ip.h>
#include <uapi/linux/tcp.h>

BPF_HASH(block_port, u32, u16); // key: 0, value: port

int drop_tcp(struct __sk_buff *skb) {
    u16 *port;
    u32 key = 0;

    port = block_port.lookup(&key);
    if (!port) return 1; // allow if no port is set

    void *data = (void *)(long)skb->data;
    void *data_end = (void *)(long)skb->data_end;

    struct ethhdr *eth = data;
    if ((void *)eth + sizeof(*eth) > data_end) return 1;

    if (eth->h_proto != bpf_htons(ETH_P_IP)) return 1;

    struct iphdr *ip = data + sizeof(*eth);
    if ((void *)ip + sizeof(*ip) > data_end) return 1;

    if (ip->protocol != IPPROTO_TCP) return 1;

    struct tcphdr *tcp = (void *)ip + ip->ihl * 4;
    if ((void *)tcp + sizeof(*tcp) > data_end) return 1;

    if (bpf_ntohs(tcp->dest) == *port) {
        return 0; // drop packet
    }

    return 1; // allow others
}
"""

# Load and compile the eBPF program
b = BPF(text=bpf_program)
fn = b.load_func("drop_tcp", BPF.SOCKET_FILTER)

# Set the port to block (default: 4040)
PORT = 4040
key = ctypes.c_uint(0)
value = ctypes.c_ushort(PORT)
b["block_port"][key] = value

# Attach to network interface
sock = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.ntohs(3))
sock.bind(("eth0", 0))  # Replace "eth0" with your actual interface
b.attach_raw_socket(fn, "eth0")

print(f"âœ… eBPF filter active: Dropping TCP packets on port {PORT}")
